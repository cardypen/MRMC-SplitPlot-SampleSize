---
title: "Validation"
format:   
  html:
    self-contained: true
    toc: true
    number-depth: 3
editor: visual
execute-dir: project
execute:
  echo: false
  warning: false
---

## Validation Methods (In Progess)

The goal is to show that the method used to power studies in the MRMC Sample Size app aligns with published research.

### Inputs

The app takes in parameters in Obuchowski-Rockette (OR) form. This form is the most clinically relevant. These parameters are converted to Roe-Metz-Hillis (RMH) parameters.

## Results directly from RMH Parameters from Chen, Gong, Gallas 2018:

```{r}
source("functions_moments.R")

library(purrr)
library(gt)
library(tidyverse)
library(dplyr)
library(fpow)
```

```{r}

# Chen, Gong, Gallas Table 1 scenarios
scenarios <- list(
  # HH
  list(structure="HH", AUC1=0.65, AUC2=0.70, sigma_r=0.011, sigma_tr=0.011,
       sigma_C=0.3, sigma_TC=0.3, sigma_RC=0.2, sigma_trc=0.2),
  list(structure="HH", AUC1=0.80, AUC2=0.85, sigma_r=0.030, sigma_tr=0.030,
       sigma_C=0.3, sigma_TC=0.3, sigma_RC=0.2, sigma_trc=0.2),
  list(structure="HH", AUC1=0.90, AUC2=0.95, sigma_r=0.056, sigma_tr=0.056,
       sigma_C=0.3, sigma_TC=0.3, sigma_RC=0.2, sigma_trc=0.2),
  # HL
  list(structure="HL", AUC1=0.65, AUC2=0.70, sigma_r=0.0055, sigma_tr=0.0055,
       sigma_C=0.3, sigma_TC=0.3, sigma_RC=0.2, sigma_trc=0.2),
  list(structure="HL", AUC1=0.80, AUC2=0.85, sigma_r=0.0055, sigma_tr=0.0055,
       sigma_C=0.3, sigma_TC=0.3, sigma_RC=0.2, sigma_trc=0.2),
  list(structure="HL", AUC1=0.90, AUC2=0.95, sigma_r=0.0055, sigma_tr=0.0055,
       sigma_C=0.3, sigma_TC=0.3, sigma_RC=0.2, sigma_trc=0.2),
  # LH
  list(structure="LH", AUC1=0.65, AUC2=0.70, sigma_r=0.011, sigma_tr=0.011,
       sigma_C=0.1, sigma_TC=0.1, sigma_RC=0.2, sigma_trc=0.6),
  list(structure="LH", AUC1=0.80, AUC2=0.85, sigma_r=0.030, sigma_tr=0.030,
       sigma_C=0.1, sigma_TC=0.1, sigma_RC=0.2, sigma_trc=0.6),
  list(structure="LH", AUC1=0.90, AUC2=0.95, sigma_r=0.056, sigma_tr=0.056,
       sigma_C=0.1, sigma_TC=0.1, sigma_RC=0.2, sigma_trc=0.6),
  # LL
  list(structure="LL", AUC1=0.65, AUC2=0.70, sigma_r=0.0055, sigma_tr=0.0055,
       sigma_C=0.1, sigma_TC=0.1, sigma_RC=0.2, sigma_trc=0.6),
  list(structure="LL", AUC1=0.80, AUC2=0.85, sigma_r=0.0055, sigma_tr=0.0055,
       sigma_C=0.1, sigma_TC=0.1, sigma_RC=0.2, sigma_trc=0.6),
  list(structure="LL", AUC1=0.90, AUC2=0.95, sigma_r=0.0055, sigma_tr=0.0055,
       sigma_C=0.1, sigma_TC=0.1, sigma_RC=0.2, sigma_trc=0.6)
)

# ---- run all scenarios ----
results <- map_df(scenarios, evaluate_power_all, N0=80, N1=60, NR=16)

# Prepare data: separate variance and power columns for each design
results_wide <- results %>%
  mutate(var_x1e3 = 1000 * var_delta,
         power_pct = 100 * power) %>%
  select(structure, AUC1, AUC2, design, var_x1e3, power_pct) %>%
  pivot_wider(
    names_from = design,
    values_from = c(var_x1e3, power_pct)
  )

# Build gt table with top-level spanners
results_gt <- results_wide %>%
  gt(rowname_col = "structure") %>%
  tab_spanner(
    label = "Variance (×1000)",
    columns = starts_with("var_x1e3")
  ) %>%
  tab_spanner(
    label = "Power (%)",
    columns = starts_with("power_pct")
  ) %>%
  cols_label(
    var_x1e3_FC = "FC", var_x1e3_PSP2 = "PSP2",
    var_x1e3_PSP4 = "PSP4", var_x1e3_PSP8 = "PSP8",
    power_pct_FC = "FC", power_pct_PSP2 = "PSP2",
    power_pct_PSP4 = "PSP4", power_pct_PSP8 = "PSP8"
  ) %>%
  fmt_number(
    columns = starts_with("var_x1e3"),
    decimals = 2
  ) %>%
  fmt_number(
    columns = starts_with("power_pct"),
    decimals = 1
  )

results_gt

```

## Results from OR Parameters with conversion:

```{r}
### convert original RMH parameters to OR parameters to match how it will be used in practice
tab1_OR_params <- list()
for (i in seq_along(scenarios)) {
  scen <- scenarios[[i]]
  OR_params <- convert_to_OR(AUC1 = scen$AUC1, AUC2 = scen$AUC2, 
                             var_R = scen$sigma_r,
                             var_TR = scen$sigma_tr, var_C = scen$sigma_C,
                             var_TC = scen$sigma_TC, var_RC = scen$sigma_RC,
                             var_error = scen$sigma_trc, n0 = 80, n1 = 60)
  tab1_OR_params[[i]] <- OR_params
}

converted_RMH_params<- map_df(tab1_OR_params, OR_to_RMH)


# ---- run all scenarios ----
struct<-c(rep("HH", 3), rep("HL", 3), rep("LH", 3), rep("LL", 3))

converted_RMH_params2<-converted_RMH_params %>% 
  select(n0, n1, delta1, delta2, 
         var_R, var_TR, var_C, 
         var_TC, var_RC, var_error) %>%
  mutate(structure = struct)


df_list <- split(converted_RMH_params2, seq(nrow(converted_RMH_params2)))
df_list <- lapply(df_list, as.list)

results2 <- map_df(df_list, evaluate_power_new, NR=16)

# Prepare data: separate variance and power columns for each design
results_wide2 <- results2 %>%
  mutate(var_x1e3 = 1000 * var_delta,
         power_pct = 100 * power) %>%
  select(structure, AUC1, AUC2, design, var_x1e3, power_pct) %>%
  pivot_wider(
    names_from = design,
    values_from = c(var_x1e3, power_pct)
  )

# Build gt table with top-level spanners
results_gt2 <- results_wide2 %>%
  gt(rowname_col = "structure") %>%
  tab_spanner(
    label = "Variance (×1000)",
    columns = starts_with("var_x1e3")
  ) %>%
  tab_spanner(
    label = "Power (%)",
    columns = starts_with("power_pct")
  ) %>%
  cols_label(
    var_x1e3_FC = "FC", var_x1e3_PSP2 = "PSP2",
    var_x1e3_PSP4 = "PSP4", var_x1e3_PSP8 = "PSP8",
    power_pct_FC = "FC", power_pct_PSP2 = "PSP2",
    power_pct_PSP4 = "PSP4", power_pct_PSP8 = "PSP8"
  ) %>%
  fmt_number(
    columns = starts_with("var_x1e3"),
    decimals = 2
  ) %>%
  fmt_number(
    columns = starts_with("power_pct"),
    decimals = 1
  )

results_gt2
```

## Validate Sample Size with Table 3:

Note: The sample sizes in Table 3 in Chen/Gong/Gallas by iteratively solving the number of cases each reader needs to read such that a power of 80% is achieved. Our sample sizes were also calculated iteratively using uniroot.

```{r}

results_FC <- purrr::map_df(
  scenarios,
  ~ {
    out <- uniroot_case_ss(.x, NR = 16, design = "FC", r = 0.75)
    tibble::as_tibble(out) %>% mutate(structure = .x$structure)
  }
)

results_PSP2 <- purrr::map_df(
  scenarios,
  ~ {
    out <- uniroot_case_ss(.x, NR = 16, design = "PSP_equal", G = 2, r = 0.75)
    tibble::as_tibble(out) %>% mutate(structure = .x$structure, design = "PSP2")
  }
)

results_PSP4 <- purrr::map_df(
  scenarios,
  ~ {
    out <- uniroot_case_ss(.x, NR = 16, design = "PSP_equal", G = 4, r = 0.75)
    tibble::as_tibble(out) %>% mutate(structure = .x$structure, design = "PSP4")
  }
)

results_PSP8 <- purrr::map_df(
  scenarios,
  ~ {
    out <- uniroot_case_ss(.x, NR = 16, design = "PSP_equal", G = 8, r = 0.75)
    tibble::as_tibble(out) %>% mutate(structure = .x$structure, design = "PSP8")
  }
)



# Combine them
results_all <- bind_rows(results_FC, results_PSP2, results_PSP4, results_PSP8)



results_wide_ss <- results_all %>%
  mutate(
    # per-reader workload
    N_total_reader = N0 + N1,
    # group multiplier
    G = case_when(
      design == "FC"   ~ 1L,
      design == "PSP2" ~ 2L,
      design == "PSP4" ~ 4L,
      design == "PSP8" ~ 8L,
      TRUE ~ 1L
    ),
    # total distinct across groups
    N_total_distinct  = (N0 + N1) * G
  ) %>%
  select(structure, design, AUC1, AUC2,
         N_total_reader, N_total_distinct, achieved_power)

# Pivot wider so each design (FC, PSP2, PSP4, PSP8) becomes columns
results_wide_ss <- results_wide_ss %>%
  tidyr::pivot_wider(
    id_cols = c(structure, AUC1, AUC2),
    names_from = design,
    values_from = c(N_total_reader, N_total_distinct, achieved_power)
  )

# Build gt table with top-level spanners (like Chen Table 3)
results_gt_ss <- results_wide_ss %>%
  gt(rowname_col = "structure") %>%
  tab_spanner(
    label = "Cases per Reader",
    columns = starts_with("N_total_reader")
  ) %>%
  tab_spanner(
    label = "Total Number of Cases",
    columns = starts_with("N_total_distinct")
  ) %>%
  tab_spanner(
    label = "Achieved Power",
    columns = starts_with("achieved_power")
  ) %>%
  cols_label(
    N_total_reader_FC = "FC", N_total_reader_PSP2 = "PSP2",
    N_total_reader_PSP4 = "PSP4", N_total_reader_PSP8 = "PSP8",
    N_total_distinct_FC = "FC", N_total_distinct_PSP2 = "PSP2",
    N_total_distinct_PSP4 = "PSP4", N_total_distinct_PSP8 = "PSP8",
    achieved_power_FC = "FC", achieved_power_PSP2 = "PSP2",
    achieved_power_PSP4 = "PSP4", achieved_power_PSP8 = "PSP8"
  ) %>%
  fmt_number(columns = starts_with("N_total_reader"), decimals = 0) %>%
  fmt_number(columns = starts_with("N_total_distinct"), decimals = 0) %>%
  fmt_number(columns = starts_with("achieved_power"), decimals = 3)


results_gt_ss



```

## Validate Sample Size with MRMCsamplesize:

```{r}

library(MRMCsamplesize)

tab1_df <- bind_rows(tab1_OR_params, .id = "scenario")

tab1_mrmc_ss_params <- tab1_df %>% rowwise() %>%
  mutate(delta = AUC2-AUC1,
         J = 16,
         lambda = ncparamF(0.05, 1-0.8, nu1 = 1, nu2 = 1*(16-1)),
         K=1,
         rangew_new_num_num = (J*delta^2)/(2*lambda)-var_TR,
         rangew_new_num_denom = (1-corr1) + (J-1)*(corr2-corr3),
         rangew_new_num = (4*sqrt(var_error-rangew_new_num_num/rangew_new_num_denom)),
         rangew_new_denom = sqrt(1/(K*((1-corr1) + (J-1)*(corr2-corr3))+1)),
         rangew_new = rangew_new_num/rangew_new_denom
         ) %>%
  mutate(rangew_new = case_when(is.nan(rangew_new) ~ 0.000001,
                                .default = rangew_new))

#rb = 1 - varTR/varR

# new rangew:
# depends on J, delta, K, lambda, var_TR, var_error, corr1, corr2, corr3
# rangew_new_num_num <- (J*delta^2)/(2*lambda)-scen$var_TR
# rangew_new_num_denom <- (1-scen$corr1) + (J-1)*(scen$corr2-scen$corr3)
# rangew_new_num <- (4*sqrt(scen$var_error-rangew_new_num_num/rangew_new_num_denom))
# rangew_new_denom <- sqrt(1/(K*((1-scen$corr1) + (J-1)*(scen$corr2-scen$corr3))+1))
# 
# rangew_new <- rangew_new_num/rangew_new_denom
###### error on scenario 12... var_error is so small that it tries to take neg sqrt



results_pkg_df <- tab1_mrmc_ss_params %>%
  mutate(J = 16) %>%
  pmap_dfr(function(n0, n1, AUC1, AUC2, var_R, var_TR, var_error,
                    cov1, cov2, cov3, corr1, corr2, corr3, b,
                    mean_to_sig1, mean_to_sig2, Pr1_improper,
                    Pr2_improper, delta, J, lambda, K,
                    rangew_new_num_num, rangew_new_num_denom,
                    rangew_new_num, rangew_new_denom, rangew_new, ...) {

    res <- sampleSize_MRMC(
      endpoint = "AUC",
      J = J,
      delta = 0.05,
      rangeb = 4 * sqrt(var_R),      # correct
      rangew = rangew_new,
      theta = min(c(AUC1, AUC2)),
      R = 4/3,
      r1 = corr1,
      r2 = corr2,
      r3 = corr3,
      rb = 1 - (var_TR / var_R),
      alpha = 0.05,
      power = 0.80,
      reader_var_estimation_method = "not normal"
    )$ORSampleSizeResults

    # Return as tibble (one row per scenario)
    as_tibble(res)
  })





















# results_pkg_df <- do.call(rbind, lapply(seq_along(tab1_OR_params), function(i) {
#   scen <- tab1_OR_params[[i]]
#   res <- sampleSize_MRMC(
#     endpoint = "AUC",
#     J = 16,
#     delta = 0.05,
#     rangeb = 4*sqrt(scen$var_R), #this is correct from line 116 in mrmcsamplesize
#     rangew = 4*sqrt(scen$var_TR), ## this might not be quite this simple
#     theta = min(c(scen$AUC1, scen$AUC2)),
#     R = 4/3, 
#     r1 = scen$corr1,
#     r2 = scen$corr2,
#     r3 = scen$corr3,
#     rb = 1 - (scen$var_TR/scen$var_R),
#     alpha = 0.05,
#     power = 0.80,
#     reader_var_estimation_method = "not normal"
#   )$ORSampleSizeResults
# }))
# 
# 
# results_pkg_df


# sampleSize_MRMC(endpoint = "auc",
#                 J = 16,
#                 delta = 0.05,
#                 rangeb = 4 * sqrt(scen$var_R),
#                 rangew = 4 * sqrt(scen$var_TR + scen$var_error),
#                 theta = mean(scen$AUC1,scen$AUC2),
#                 R = 0.75, 
#                 r1 = scen$corr1,
#                 r2 = scen$corr2,
#                 r3 = scen$corr3)


```

## References (need to format consistently)

Chen, W; Gong, Q; Gallas, B. D, 'Paired split-plot designs of multireader multicase studies,' J. Med. Imag. **5**(3), 031410 (2018)

Brandon D. Gallas, Stephen L. Hillis, "Generalized Roe and Metz receiver operating characteristic model: analytic link between simulated decision scores and empirical AUC variances and covariances," J. Med. Imag. 1(3) 031006 (25 September 2014)<https://doi.org/10.1117/1.JMI.1.3.031006>

Hillis SL. Relationship between Roe and Metz simulation model for multireader diagnostic data and Obuchowski-Rockette model parameters. Stat Med. 2018 Jun 15;37(13):2067-2093. doi: 10.1002/sim.7616. Epub 2018 Apr 2. PMID: 29609206; PMCID: PMC5980727.
