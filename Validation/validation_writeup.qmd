---
title: "Validation"
format:   
  html:
    self-contained: true
    toc: true
    number-depth: 3
editor: visual
execute-dir: project
execute:
  echo: false
  warning: false
---

## Validation Methods (In Progess)

The goal is to show that the method used to power studies in the MRMC Sample Size app aligns with published research.

### Inputs

The app takes in parameters in Obuchowski-Rockette (OR) form. This form is the most clinically relevant. These parameters are converted to Roe-Metz-Hillis (RMH) parameters.

## Results directly from RMH Parameters from Chen, Gong, Gallas 2018:

```{r}
source("functions_moments.R")

library(purrr)
library(gt)
library(tidyverse)
library(dplyr)
```

```{r}

# Chen, Gong, Gallas Table 1 scenarios
scenarios <- list(
  # HH
  list(structure="HH", AUC1=0.65, AUC2=0.70, sigma_r=0.011, sigma_tr=0.011,
       sigma_C=0.3, sigma_TC=0.3, sigma_RC=0.2, sigma_trc=0.2),
  list(structure="HH", AUC1=0.80, AUC2=0.85, sigma_r=0.030, sigma_tr=0.030,
       sigma_C=0.3, sigma_TC=0.3, sigma_RC=0.2, sigma_trc=0.2),
  list(structure="HH", AUC1=0.90, AUC2=0.95, sigma_r=0.056, sigma_tr=0.056,
       sigma_C=0.3, sigma_TC=0.3, sigma_RC=0.2, sigma_trc=0.2),
  # HL
  list(structure="HL", AUC1=0.65, AUC2=0.70, sigma_r=0.0055, sigma_tr=0.0055,
       sigma_C=0.3, sigma_TC=0.3, sigma_RC=0.2, sigma_trc=0.2),
  list(structure="HL", AUC1=0.80, AUC2=0.85, sigma_r=0.0055, sigma_tr=0.0055,
       sigma_C=0.3, sigma_TC=0.3, sigma_RC=0.2, sigma_trc=0.2),
  list(structure="HL", AUC1=0.90, AUC2=0.95, sigma_r=0.0055, sigma_tr=0.0055,
       sigma_C=0.3, sigma_TC=0.3, sigma_RC=0.2, sigma_trc=0.2),
  # LH
  list(structure="LH", AUC1=0.65, AUC2=0.70, sigma_r=0.011, sigma_tr=0.011,
       sigma_C=0.1, sigma_TC=0.1, sigma_RC=0.2, sigma_trc=0.6),
  list(structure="LH", AUC1=0.80, AUC2=0.85, sigma_r=0.030, sigma_tr=0.030,
       sigma_C=0.1, sigma_TC=0.1, sigma_RC=0.2, sigma_trc=0.6),
  list(structure="LH", AUC1=0.90, AUC2=0.95, sigma_r=0.056, sigma_tr=0.056,
       sigma_C=0.1, sigma_TC=0.1, sigma_RC=0.2, sigma_trc=0.6),
  # LL
  list(structure="LL", AUC1=0.65, AUC2=0.70, sigma_r=0.0055, sigma_tr=0.0055,
       sigma_C=0.1, sigma_TC=0.1, sigma_RC=0.2, sigma_trc=0.6),
  list(structure="LL", AUC1=0.80, AUC2=0.85, sigma_r=0.0055, sigma_tr=0.0055,
       sigma_C=0.1, sigma_TC=0.1, sigma_RC=0.2, sigma_trc=0.6),
  list(structure="LL", AUC1=0.90, AUC2=0.95, sigma_r=0.0055, sigma_tr=0.0055,
       sigma_C=0.1, sigma_TC=0.1, sigma_RC=0.2, sigma_trc=0.6)
)

# ---- run all scenarios ----
results <- map_df(scenarios, evaluate_power_all, N0=80, N1=60, NR=16)

# Prepare data: separate variance and power columns for each design
results_wide <- results %>%
  mutate(var_x1e3 = 1000 * var_delta,
         power_pct = 100 * power) %>%
  select(structure, AUC1, AUC2, design, var_x1e3, power_pct) %>%
  pivot_wider(
    names_from = design,
    values_from = c(var_x1e3, power_pct)
  )

# Build gt table with top-level spanners
results_gt <- results_wide %>%
  gt(rowname_col = "structure") %>%
  tab_spanner(
    label = "Variance (×1000)",
    columns = starts_with("var_x1e3")
  ) %>%
  tab_spanner(
    label = "Power (%)",
    columns = starts_with("power_pct")
  ) %>%
  cols_label(
    var_x1e3_FC = "FC", var_x1e3_PSP2 = "PSP2",
    var_x1e3_PSP4 = "PSP4", var_x1e3_PSP8 = "PSP8",
    power_pct_FC = "FC", power_pct_PSP2 = "PSP2",
    power_pct_PSP4 = "PSP4", power_pct_PSP8 = "PSP8"
  ) %>%
  fmt_number(
    columns = starts_with("var_x1e3"),
    decimals = 2
  ) %>%
  fmt_number(
    columns = starts_with("power_pct"),
    decimals = 1
  )

results_gt

```

## Results from OR Parameters with conversion:

```{r}
### convert original RMH parameters to OR parameters to match how it will be used in practice
tab1_OR_params <- list()
for (i in seq_along(scenarios)) {
  scen <- scenarios[[i]]
  OR_params <- convert_to_OR(AUC1 = scen$AUC1, AUC2 = scen$AUC2, 
                             var_R = scen$sigma_r,
                             var_TR = scen$sigma_tr, var_C = scen$sigma_C,
                             var_TC = scen$sigma_TC, var_RC = scen$sigma_RC,
                             var_error = scen$sigma_trc, n0 = 80, n1 = 60)
  tab1_OR_params[[i]] <- OR_params
}

converted_RMH_params<- map_df(tab1_OR_params, OR_to_RMH)


# ---- run all scenarios ----
struct<-c(rep("HH", 3), rep("HL", 3), rep("LH", 3), rep("LL", 3))

converted_RMH_params2<-converted_RMH_params %>% 
  select(n0, n1, delta1, delta2, 
         var_R, var_TR, var_C, 
         var_TC, var_RC, var_error) %>%
  mutate(structure = struct)


df_list <- split(converted_RMH_params2, seq(nrow(converted_RMH_params2)))
df_list <- lapply(df_list, as.list)

results2 <- map_df(df_list, evaluate_power_new, NR=16)

# Prepare data: separate variance and power columns for each design
results_wide2 <- results2 %>%
  mutate(var_x1e3 = 1000 * var_delta,
         power_pct = 100 * power) %>%
  select(structure, AUC1, AUC2, design, var_x1e3, power_pct) %>%
  pivot_wider(
    names_from = design,
    values_from = c(var_x1e3, power_pct)
  )

# Build gt table with top-level spanners
results_gt2 <- results_wide2 %>%
  gt(rowname_col = "structure") %>%
  tab_spanner(
    label = "Variance (×1000)",
    columns = starts_with("var_x1e3")
  ) %>%
  tab_spanner(
    label = "Power (%)",
    columns = starts_with("power_pct")
  ) %>%
  cols_label(
    var_x1e3_FC = "FC", var_x1e3_PSP2 = "PSP2",
    var_x1e3_PSP4 = "PSP4", var_x1e3_PSP8 = "PSP8",
    power_pct_FC = "FC", power_pct_PSP2 = "PSP2",
    power_pct_PSP4 = "PSP4", power_pct_PSP8 = "PSP8"
  ) %>%
  fmt_number(
    columns = starts_with("var_x1e3"),
    decimals = 2
  ) %>%
  fmt_number(
    columns = starts_with("power_pct"),
    decimals = 1
  )

results_gt2
```

## Validate Sample Size with Table 3:

Note: The sample sizes in Table 3 in Chen/Gong/Gallas by iteratively solving the number of cases each reader needs to read such that a power of 80% is achieved. Our sample sizes were also calculated iteratively using uniroot.

```{r}

results_FC <- purrr::map_df(
  scenarios,
  ~ {
    out <- uniroot_case_ss(.x, NR = 16, design = "FC", r = 0.75)
    tibble::as_tibble(out) %>% mutate(structure = .x$structure)
  }
)

results_PSP2 <- purrr::map_df(
  scenarios,
  ~ {
    out <- uniroot_case_ss(.x, NR = 16, design = "PSP_equal", G = 2, r = 0.75)
    tibble::as_tibble(out) %>% mutate(structure = .x$structure, design = "PSP2")
  }
)

results_PSP4 <- purrr::map_df(
  scenarios,
  ~ {
    out <- uniroot_case_ss(.x, NR = 16, design = "PSP_equal", G = 4, r = 0.75)
    tibble::as_tibble(out) %>% mutate(structure = .x$structure, design = "PSP4")
  }
)

results_PSP8 <- purrr::map_df(
  scenarios,
  ~ {
    out <- uniroot_case_ss(.x, NR = 16, design = "PSP_equal", G = 8, r = 0.75)
    tibble::as_tibble(out) %>% mutate(structure = .x$structure, design = "PSP8")
  }
)



# Combine them
results_all <- bind_rows(results_FC, results_PSP2, results_PSP4, results_PSP8)



results_wide_ss <- results_all %>%
  mutate(
    # per-reader workload
    N_total_reader = N0 + N1,
    # group multiplier
    G = case_when(
      design == "FC"   ~ 1L,
      design == "PSP2" ~ 2L,
      design == "PSP4" ~ 4L,
      design == "PSP8" ~ 8L,
      TRUE ~ 1L
    ),
    # total distinct across groups
    N_total_distinct  = (N0 + N1) * G
  ) %>%
  select(structure, design, AUC1, AUC2,
         N_total_reader, N_total_distinct, achieved_power)

# Pivot wider so each design (FC, PSP2, PSP4, PSP8) becomes columns
results_wide_ss <- results_wide_ss %>%
  tidyr::pivot_wider(
    id_cols = c(structure, AUC1, AUC2),
    names_from = design,
    values_from = c(N_total_reader, N_total_distinct, achieved_power)
  )

# Build gt table with top-level spanners (like Chen Table 3)
results_gt_ss <- results_wide_ss %>%
  gt(rowname_col = "structure") %>%
  tab_spanner(
    label = "Cases per Reader",
    columns = starts_with("N_total_reader")
  ) %>%
  tab_spanner(
    label = "Total Number of Cases",
    columns = starts_with("N_total_distinct")
  ) %>%
  tab_spanner(
    label = "Achieved Power",
    columns = starts_with("achieved_power")
  ) %>%
  cols_label(
    N_total_reader_FC = "FC", N_total_reader_PSP2 = "PSP2",
    N_total_reader_PSP4 = "PSP4", N_total_reader_PSP8 = "PSP8",
    N_total_distinct_FC = "FC", N_total_distinct_PSP2 = "PSP2",
    N_total_distinct_PSP4 = "PSP4", N_total_distinct_PSP8 = "PSP8",
    achieved_power_FC = "FC", achieved_power_PSP2 = "PSP2",
    achieved_power_PSP4 = "PSP4", achieved_power_PSP8 = "PSP8"
  ) %>%
  fmt_number(columns = starts_with("N_total_reader"), decimals = 0) %>%
  fmt_number(columns = starts_with("N_total_distinct"), decimals = 0) %>%
  fmt_number(columns = starts_with("achieved_power"), decimals = 3)


results_gt_ss



```

## Validate Sample Size with MRMCsamplesize:

```{r}

library(MRMCsamplesize)



results_pkg_df <- do.call(rbind, lapply(seq_along(tab1_OR_params), function(i) {
  scen <- tab1_OR_params[[i]]
  res <- sampleSize_MRMC(
    endpoint = "AUC",
    J = 16,
    delta = scen$AUC2 - scen$AUC1,
    rangeb = 2 * sqrt(scen$var_R),
    rangew = 2 * sqrt(scen$var_TR + scen$var_error),
    theta = mean(c(scen$AUC1, scen$AUC2)),
    R = 0.75, 
    r1 = scen$corr1,
    r2 = scen$corr2,
    r3 = scen$corr3,
    alpha = 0.05,
    power = 0.80
  )
  
  data.frame(
    scenario = i,
    AUC1 = scen$AUC1,
    AUC2 = scen$AUC2,
    delta = scen$AUC2 - scen$AUC1,
    theta = mean(c(scen$AUC1, scen$AUC2)),
    rangeb = 4 * sqrt(scen$var_R),
    rangew = 4 * sqrt(scen$var_TR + scen$var_error),
    r1 = scen$corr1,
    r2 = scen$corr2,
    r3 = scen$corr3,
    sample_size = res$sampleSize
  )
}))





# sampleSize_MRMC(endpoint = "auc",
#                 J = 16,
#                 delta = 0.05,
#                 rangeb = 4 * sqrt(scen$var_R),
#                 rangew = 4 * sqrt(scen$var_TR + scen$var_error),
#                 theta = mean(scen$AUC1,scen$AUC2),
#                 R = 0.75, 
#                 r1 = scen$corr1,
#                 r2 = scen$corr2,
#                 r3 = scen$corr3)


```

## References (need to format consistently)

Chen, W; Gong, Q; Gallas, B. D, 'Paired split-plot designs of multireader multicase studies,' J. Med. Imag. **5**(3), 031410 (2018)

Brandon D. Gallas, Stephen L. Hillis, "Generalized Roe and Metz receiver operating characteristic model: analytic link between simulated decision scores and empirical AUC variances and covariances," J. Med. Imag. 1(3) 031006 (25 September 2014)<https://doi.org/10.1117/1.JMI.1.3.031006>

Hillis SL. Relationship between Roe and Metz simulation model for multireader diagnostic data and Obuchowski-Rockette model parameters. Stat Med. 2018 Jun 15;37(13):2067-2093. doi: 10.1002/sim.7616. Epub 2018 Apr 2. PMID: 29609206; PMCID: PMC5980727.
